//
// ROM Board Tester
//
// Try to get the Flash memory Status from our custom ROM boards
//

/*
	This app uses a backdoor that we open up in a pached ROM via SWI12.
	Setting r0 to 0x0badcafe and calling SWI12 will jump to the address
	in r1 in SVC mode. r0 will now contain the return address to get back
	into USER mode and return form the SWI.

	When in SVC mode, we can manipulate the MMU tables to allow easy 
	write access to the ROM card. Also in SVC mode, we must disable 
	read and write caches while sending commands to the Flash.

	Virtual mapping at 0: 0 U C B R (0010081E) 
		03500000: 0 u c b R (00100802, P040000D4: 00000802, 00100802, etc.)
		10000000: 0 u c b RW
		Domain Mask: 0x000003E0
		Permission Mask: 0x00000C00, 11 = r/w all
 */

yButton := 10;
address := 0x10000000;
data := MakeBinaryFromHex("BEEFCAFE", 'data);
dataBlock := MakeBinaryFromHex("0102030405060708DEADBEEF", 'data);

kAppName := "ROMBoardTester:WONKO";
kAppSymbol := '|ROMBoardTester:WONKO|;
kAppLabel := "ROMBoard Tester";

ARMCode := MakeBinaryFromARMFile("BoardTester.s");

newt.theForm := {
	_proto: protoFloatNGo,
	viewBounds: {
		left: 0, top: 50, right: 200, bottom: 320
	},
	abc: 1,
	flash: nil,
	FlashInit:        { class: 'BinCFunction, numArgs: 1, offset: 0, code: ARMCode },
	FlashDone:        { class: 'BinCFunction, numArgs: 1, offset: 4, code: ARMCode },
	// Backdoor
	FlashRead:        { class: 'BinCFunction, numArgs: 2, offset: 12, code: ARMCode },
	FlashStatus:      { class: 'BinCFunction, numArgs: 1, offset: 16, code: ARMCode },
	FlashErase:       { class: 'BinCFunction, numArgs: 2, offset: 20, code: ARMCode },
	FlashWrite:       { class: 'BinCFunction, numArgs: 3, offset: 24, code: ARMCode },
	FlashWriteBlock:  { class: 'BinCFunction, numArgs: 3, offset: 28, code: ARMCode },
	FlashClearStatus: { class: 'BinCFunction, numArgs: 1, offset: 32, code: ARMCode },
};

FlashInitButton := {
	_proto: protoTextButton,
	text: "Flash Init",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			flash := :FlashInit('FlashROM);
			Print(flash);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashInitButton);
StepDeclare(newt.theForm, FlashInitButton, 'FlashInitButton);
yButton := yButton + 18;


FlashReadButton := {
	_proto: protoTextButton,
	text: "Read Flash",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashRead(flash, address);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashReadButton);
StepDeclare(newt.theForm, FlashReadButton, 'FlashReadButton);
yButton := yButton + 18;


FlashRead2Button := {
	_proto: protoTextButton,
	text: "Read Flash 2",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashRead(flash, address+4);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashRead2Button);
StepDeclare(newt.theForm, FlashRead2Button, 'FlashRead2Button);
yButton := yButton + 18;


FlashWriteButton := {
	_proto: protoTextButton,
	text: "Write Flash",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashWrite(flash, address, data);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashWriteButton);
StepDeclare(newt.theForm, FlashWriteButton, 'FlashWriteButton);
yButton := yButton + 18;


FlashWriteBlockButton := {
	_proto: protoTextButton,
	text: "Write Block",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashWriteBlock(flash, address, dataBlock);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashWriteBlockButton);
StepDeclare(newt.theForm, FlashWriteBlockButton, 'FlashWriteBlockButton);
yButton := yButton + 18;


FlashEraseButton := {
	_proto: protoTextButton,
	text: "Erase Sector",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashErase(flash, address);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashEraseButton);
StepDeclare(newt.theForm, FlashEraseButton, 'FlashEraseButton);
yButton := yButton + 18;


FlashClearStatusButton := {
	_proto: protoTextButton,
	text: "Clear Status",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashClearStatus(flash);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashClearStatusButton);
StepDeclare(newt.theForm, FlashClearStatusButton, 'FlashClearStatusButton);
yButton := yButton + 18;


FlashStatusButton := {
	_proto: protoTextButton,
	text: "Flash Status",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			ret := :FlashStatus(flash);
			Print(ret);
			Print(StrHexDump(flash, 4));
			SetValue(FlashStatusText, 'text, StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashStatusButton);
StepDeclare(newt.theForm, FlashStatusButton, 'FlashStatusButton);
yButton := yButton + 18;


FlashDoneButton := {
	_proto: protoTextButton,
	text: "Flash Done",
	viewBounds: RelBounds(10, yButton, 80, 12),
	ButtonClickScript: func() begin
			:FlashDone(flash);
			Print("Flash Done:");
			Print(StrHexDump(flash, 4));
		end,
};
AddStepForm(newt.theForm, FlashDoneButton);
StepDeclare(newt.theForm, FlashDoneButton, 'FlashDoneButton);
yButton := yButton + 18;


FlashStatusText := {
	viewBounds: RelBounds(10, yButton, 180, 200-yButton),
	viewClass: clParagraphView,
	viewJustify: 0,
	viewFlags: vVisible,
	viewFont: ROM_fontsystem9bold,
	text: "Flash Status output",
};
AddStepForm(newt.theForm, FlashStatusText);
StepDeclare(newt.theForm, FlashStatusText, 'FlashStatusText);




Test1Result := {
	_proto: protoStaticText,
	nativeMath: {
		class : 'BinCFunction,
		numArgs: 2,
		offset: 0,
		code: MakeBinaryFromARM("
			@.word 0xE1200070
			ldr r0, =0x0badcafe
			mov r2, #0
			add r1, pc, #8
			swi 12					@ enter SVC mode
			mov r0, r2, lsl #2		@ convert the result into an integer object
			mov pc, lr				@ return to the interpreter

		svc_call:

			@.word 0xE1200070
			stmdb sp!, {r0, lr}		@ save return address in r0

			adr r0, runPhys			@ jump to this address in physical RAM
			mov lr, pc
			ldr pc, =0x0015BCC8		@ VtoP

			ldr r1, =0x00001554
			ldr r2, =0x00700070
			mov r3, #0

			adr r4, returnPhys
			mov lr, r0				@ return to the physical address
			ldr r0, =0x000011B0		@ disable I, D, and W cache, and MMU
			ldr pc, =0x007FF004		@ call 'write to control register'

			@ this code is executed in physical space
		runPhys:
			str r2, [r1]
			ldr r2, [r3]
			mov lr, r4
			ldr r0, =0x000011BD             @ enable I, D, and W cache, and MMU
			ldr pc, =0x007FF004             @ call 'write to control register'

		returnPhys:
			ldmia sp!, {r0, lr}
			mov pc, r0
			")
	},
	newtonScriptMath: func(a, b) begin
		return a+b;
	end,
	ViewSetupFormScript: func() begin
		SetValue(self, 'text, NumberStr( self:nativeMath(4, 8) ) );
	end,
	text: "Result",
	viewBounds: RelBounds(75, 12, 60, 10)
};
//AddStepForm(newt.theForm, Test1Result);
//StepDeclare(newt.theForm, Test1Result, 'Test1Result);

